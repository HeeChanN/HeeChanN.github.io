---
title: "[운영체제] 2. 운영체제(OS) 개요"
date: 2023-10-02 1:40:00 +09:00
categories: [CS, 운영체제]
tags:
  [
    운영체제,
    Multiprograming,
    kernel
  ]
---

> 이번 글에서는 OS에 대한 자세한 개념이 아니라 OS의 간략한 개념과 역사에 대해 알아보며 앞으로 배울 프로세스와 쓰레드에서 OS가 어떤 역할을 하는지 자세하게 알아보겠습니다. 따라서 이번 챕터에서는 아직 OS라는 개념과 친숙하도록 만드는게 목표라고 생각합니다!

<br>

## 1.  Operating System (OS)
---

<br>

먼저 운영체제(OS)는 응용 프로그램 (사용자 프로그램)과 컴퓨터 하드웨어 사이의 **인터페이스 역할**을 담당합니다.사용자에게 하드웨어에 대한 상세한 내용을 숨기고 시스템을 편리하게 이용할 수 있도록 도와주는 역할을 수행합니다. 또한 컴퓨터 **자원을 관리**하는 역할을 담당합니다. 컴퓨터 자원이란 CPU 메모리 등을 말하는데 이런 자원들의 효율적인 사용을 돕습니다.

> 운영체제가 이런 역할을 하는 건 알겠는데 운영체제가 도대체 뭔데요?
{: .prompt-warning }

--> 지금은 아주 간단하게 설명하면 여러분이 사용하는 윈도우나 맥 유닉스 또는 리눅스 같은 것들을 운영체제라고 말합니다. 이후에 메모리와 Scheduling에 대해 자세하게 알아갈 때 이런 운영체제의 동작 방식을 배울 것입니다. 따라서 지금은 간단하게 `**인터페이스**`의 역할을 하고 `**자원을 관리**` 한다고 기억하고 계시면 됩니다!

## 2. OS의 역할

<br>

먼저 인터페이스로 수행하는 역할에 대해 알아보고 자원 관리에 대해 알아보겠습니다.

1. User/Computer Interface :<br><br>
유저가 프로그램을 개발할 때 디버거와 프로그램 실행을 관리합니다. 이런 것들이 운영체제를 거쳐서 실행을 하게 됩니다. 또한 파일들이나 폴더에 접근할 때 역시 시스템콜을 통해 OS를 거쳐서 접근합니다. 그 밖에 I/O 장치들에 접근하거나 에러를 발견하고 응답하는 일들은 모두 OS가 제공하는 서비스입니다. <br>
따라서 OS가 이렇게 뒤에서 하드웨어를 감추고 우리에게 편리한 기능들을 제공하기에 우리는 OS를 유저와 컴퓨터 사이의 인터페이스라고 말할 수 있습니다. 

<br>

2. Resource Manager (자원 관리) :<br><br>
컴퓨터 자원에는 I/O 디바이스, 메인 메모리, 하드디스크, CPU 사용 시간 등과 같은 자원들이 존재합니다. 이런 자원들이 적절하게 사용될 수 있도록 도와주는 것이 바로 OS입니다. 이 관리에 대한 내용은 스케쥴링과 메모리 페이징 관련 내용으로 운영체제 후반부에서 자세하게 다룰 예정입니다.<br><br>

운영체제는 이렇게 다양한 서비스를 제공하기에 자주 사용되는 부분은 메인메모리에 상주하고 있어야합니다. 운영체제에서 이 부분을 `**Kernel**`이라고 부릅니다.  

> 앞으로 프로세스와 쓰레드를 다룰 떄 이 Kernel이란 용어가 자주 사용되니 기억해 두세요!!
{: .prompt-warning }

<br>

지금 까지 운영체제의 간략한 개요를 알아보았는데 운영체제가 제공해야 할 핵심 사항과 최신 운영체제의 주요 기능들이 갖는 의미를 알기 위해서 운영체제가 어떻게 변화해 왔는지 역사를 살펴 볼 필요가 있다.

## 3. 운영체제의 발전
---

<br>

![운영체제](https://github.com/HeeChanN/HeeChanN/assets/88177732/25c3196d-bd8b-4524-843f-8094113f271c)

<br>

1. Serial Processing :<br>
1940년대 부터 1950년대 중반까지 운영체제가 존재하지 않았습니다. 따라서 프로그래머가 직접 하드웨어를 다뤄야 했습니다. 기계어로 작성된 프로그램은 카드 판독기와 같은 입력장치를 통해 적재 되었습니다. 이런 프로그램에서 에러가 발생하면 인터럽트가 발생하는것이 아니라 발광체로 표시되었습니다. 프로그램이 정상적으로 완료되면 비로소 출력이 프린터에 인쇄되는 형식이었습니다. 따라서 시간도 오래걸리고 프로그래머가 하드웨어까지 만져야 되는 상황이 발생하여 효율이 떨어졌을 거라고 생각이 듭니다. 지금 우리가 서비스 프로그램을 만드는데 집중할 수 있게 만든 것이 바로 OS의 발전에 있습니다.

2. Simple Batch Sytem (단순 일괄 처리 시스템) :<br>
![uniprograming](https://github.com/HeeChanN/HeeChanN/assets/88177732/cb895c70-3832-482b-8660-756a09e1992c)
초창기 컴퓨터는 매우 고가였습니다. 따라서 컴퓨터의 이용률을 극대화 시키는 것이 중요한 목표였습니다. 일괄 처리는 컴퓨터의 이용율을 향상시키기 위해서 개발되었습니다. 컴퓨터 사용자는 작업을 카드나 테이프에 담아 제공하면 Operator는 작업들을 순서대로 한곳에 모아 작업묶음(Batch)를 입력 장치에 넣습니다. 작업 묶음에서 각 프로그램이 실행이 완료되면 바로 다음 프로그램이 실행되도록 하는 시스템입니다. 위의 그림이 해당 예시입니다.

3. Multiprogrammed Batch System :<br>

하지만 단순 일괄 처리 시스템은 CPU가 프로그램이 입출력을 대기할 동안 대기해야 하는 일이 발생하여 비효율성을 초래합니다. 따라서 CPU가 특정 프로그램을 실행하다가 입출력 대기를 할 경우 다른 프로그램에게 제어를 넘기는 방법이 바로 `**Multiprogrammed Batch System**` 입니다. 입출력 장치가 CPU에 비해 느리다는 특징을 바탕으로 앞에서 배운 인터럽트 개념이 여기서 등장합니다. 현재 프로그램이 입출력 연산으로 대기하게 될 경우 입출력 대기를 하지 않는 프로그램으로 CPU 제어를 넘기는 방법입니다. 
> 초기 멀티프로그래밍같은 경우 오직 CPU 이용율에만 집중하여 프로그램이 I/O 작업을 진행할 떄만 프로세스 스위칭이 발생했습니다. 즉, (Time out)이 존재하지 않았습니다. 이런 Time out이 왜 필요할까요? 현재 단원에서 간략하게 설명하자면 Time out이 존재하지 않으면 특정한 하나의 프로그램이 CPU를 독점할 수 있습니다. 따라서 Time out은 이런 점을 방지하기 위해 존재한다고 보면 됩니다. 나중에 성능과 fairness라는 개념에서 등장하므로 지금은 단순하게만 짚고 넘어가겠습니다!
{: .prompt-warning }

4. Time-Sharing System (시분할) :<br>
멀티프로그래밍을 이용한다면 효율적인 일괄처리가 가능해 집니다. 그러나 많은 작업이 존재할 경우 사용자와 컴퓨터 간의 직접 대화 모드를 제공하는 것이 좋습니다 (터미널, cmd).<br><br> 
멀티프로그래밍을 통해 CPU가 다수의 일괄처리 작업을 동시에 처리할 수 있는 것과 마찬가지로 다수의 대화형 작업을 처리할 때도 멀티프로그래밍 개념이 사용될 수 있는데 이를 `**시분할 기법**`이라고 합니다. 시분할 시스템에서는 각 사용자 프로그램이 짧은 시간동안 번갈아 수행되도록 해주는 운영체제를 통해 다수의 사용자가 터미널을 이용하여 동시에 시스템에 접근할 수 있습니다. 

```text
만약 서비스를 요청하는 사용자가 n명이라면 운영체제 오버헤드를 무시할 때 사용자들은 평균적으로 실제 컴퓨터 능력의 1/n만을 사용하게 된다. 하지만 이 속도도 사용자의 반응속도에 비하면 상대적으로빠르기에 각 사용자는 자신이 컴퓨터를 독점적으로 사용하는것 처럼 느낍니다.
``` 

이렇게 운영체제가 발전하며 이루어진 네가지 이론적 진전이 있습니다. **프로세스**, **메모리 관리**, **정보 보호**, **스케쥴링 및 자원관리** 입니다. 앞으로 이런 운영체제 발전의 주요 성과에 해당하는 이 4가지 요소에 대해 각 단원에서 등장할 것이고 해당 단원에서 자세하게 설명할 예정입니다. 따라서 지금은 지금까지 정리된 OS의 기능 4가지라고만 기억하시면 될 것 같습니다.

앞의 4가지 요소는 거의 대부분의 OS의 기능에 해당한다면 앞으로 나올 요소들은 OS마다 다를 수 있는 부분들 입니다.

<br>

## 3. 최근 운영체제로의 발전
---

이 방식들은 아직 정리가 진행중인 방식들로 현재 상용 운영체제들에서 시도되고 있는 작업들 입니다.

1. 단일 커널 아키텍쳐 (Microkernel Architecture) :<br>