---
title: "[운영체제] 2. 운영체제(OS) 개요"
date: 2023-10-02 2:04:00 +09:00
categories: [CS, 운영체제]
tags:
  [
    운영체제,
    Multiprograming,
    kernel
  ]
---

> OS를 저는 처음 배울 때 매우 추상적이었던 것 같아요.💭 OS가 수행하는 기능이 다양하기도 하고 너무 많은 개념이 그 내부에 속해 있어서 처음에 매우 어렵게 배웠던 것 같습니다. 이번 글에서는 운영체제가 도대체 어떤 일을 수행하는지에 대해서 알아보고 운영체제의 간략한 개요를 살펴보겠습니다! 🐣 
<br>

## 1.  Operating System (OS)
---

<br>

먼저 운영체제(OS)는 응용 프로그램 (사용자 프로그램)과 컴퓨터 하드웨어 사이의 **인터페이스 역할**을 담당합니다. 사용자에게 하드웨어에 대한 상세한 내용을 숨기고 시스템을 편리하게 이용할 수 있도록 도와주는 역할을 수행합니다. 

만약, 운영체제가 존재하지 않는다면 우리는 컴퓨터 하드웨어의 제어를 담당하는 기계명령어의 집합으로 프로그램을 개발해야하고 그 결과 우리는 온전히 프로그램에 집중하지 못하고 굉장히 복잡한 기계명령어 작업을 수행해야할 것입니다.

OS는 추가적으로 컴퓨터 **자원을 관리**하는 역할을 담당합니다. 컴퓨터 자원이란 CPU 메모리 등을 말하는데 이런 자원들의 효율적인 사용을 돕습니다.

> 운영체제가 이런 역할을 하는 건 알겠는데 운영체제가 도대체 뭔데요?
{: .prompt-warning }

--> 지금은 아주 간단하게 설명하면 여러분이 사용하는 윈도우나 맥 유닉스 또는 리눅스 같은 것들을 운영체제라고 말합니다. 따라서 지금은 간단하게 `**인터페이스**`의 역할을 하고 `**자원을 관리**`같은 여러가지 기능을 담당하는 `프로그램`입니다!

## 2. OS의 역할

<br>

OS는 다양한 서비스를 제공합니다. 그 중 몇가지 핵심적인 기능들을 살펴보겠습니다.

<br>

1. 프로그램 개발 :<br>
유저가 프로그램을 개발할 때 OS는 디버거와 문서 편집기 등 다양한 기능을 제공합니다. 이런 서비스들은 운영체제 상에서 접근할 수 프로그램 개발 도구로 제공됩니다.

<br>

2. 프로그램 실행 :<br>
하나의 프로그램이 실행 되려면 OS에 의해 여러 단계를 거쳐야합니다. 명령어와 데이터 (프로그램)이 메인 메모리에 적재 되어야하고 입출력 장치와 파일들이 초기화 되어야 하며 추가적인 필요 자원을 준비해야합니다.

<br>

3. 파일 접근 제어 :<br>
저수준 입출력 메서드 write, read 같은 것들을 단순히 읽기 쓰기의 관접에서 입출력 장치(하드 디스크)를 사용할 수 있도록 일관된 인터페이스를 제공해줍니다. 

<br>

4. 에러 발견 및 응답:<br>
컴퓨터가 동작하고 있는 동안 메인 메모리 에러, 장치 오작동같은 하드웨어 에러나 0나누기, 접근 금지 접근 시도 같은 소프트웨어 에러가 발생할 수 있는데 이런 오류가 난 프로그램을 종료하거나 연산을 재시도하는 역할을 OS가 담당합니다.

<br>

운영체제의 기능들을 살펴보면 운영체제는 컴퓨터 시스템의 자원을 관리해 주는 프로그램으로 볼 수 있습니다. 운영체제는 우리가 만드는 일반적인 프로그램과 똑같이 작동합니다 (CPU에 의해 실행됨). CPU에게 다른 시스템의 자원의 사용을 지시하고 다른 프로그램이 언제 수행될지 정해줍니다. 운영체제는 이런 작업을 수행하며 CPU가 어떤 유용한 작업을 할 수 있도록 CPU제어를 해당 프로그램에 양도한 뒤 일정 시간 뒤에 다시 돌려받는 형식으로 수행합니다.

<br>

운영체제는 이렇게 다양한 서비스를 제공하기에 자주 사용되는 부분은 메인메모리에 상주하고 있어야합니다. 운영체제에서 이 부분을 `**Kernel**`이라고 부릅니다.  

> 앞으로 프로세스와 쓰레드를 다룰 떄 이 Kernel이란 용어가 자주 사용되니 기억해 두세요!
{: .prompt-warning }

<br>

운영체제의 역할과 기능은 그럼 어떻게 발전하였고 현재는 어떤 형식으로 사용되는지를 살펴보겠습니다. 

## 3. 운영체제의 발전
---

<br>

![운영체제](https://github.com/HeeChanN/HeeChanN/assets/88177732/25c3196d-bd8b-4524-843f-8094113f271c)

<br>

1. Serial Processing :<br>
1940년대 부터 1950년대 중반까지 운영체제가 존재하지 않았습니다. 따라서 프로그래머가 직접 하드웨어를 다뤄야 했습니다. 기계어로 작성된 프로그램은 카드 판독기와 같은 입력장치를 통해 적재 되었습니다. 이런 프로그램에서 에러가 발생하면 인터럽트가 발생하는것이 아니라 발광체로 표시되었습니다. 프로그램이 정상적으로 완료되면 비로소 출력이 프린터에 인쇄되는 형식이었습니다. 따라서 시간도 오래걸리고 프로그래머가 하드웨어까지 만져야 되는 상황이 발생하여 효율이 떨어졌을 거라고 생각이 듭니다. 지금 우리가 서비스 프로그램을 만드는데 집중할 수 있게 만든 것이 바로 OS의 발전에 있습니다.

2. Simple Batch Sytem (단순 일괄 처리 시스템) :
<br>
![uniprograming](https://github.com/HeeChanN/HeeChanN/assets/88177732/cb895c70-3832-482b-8660-756a09e1992c)
<br>
초창기 컴퓨터는 매우 고가였습니다. 따라서 컴퓨터의 이용률을 극대화 시키는 것이 중요한 목표였습니다. 일괄 처리는 컴퓨터의 이용율을 향상시키기 위해서 개발되었습니다. 컴퓨터 사용자는 작업을 카드나 테이프에 담아 제공하면 Operator는 작업들을 순서대로 한곳에 모아 작업묶음(Batch)를 입력 장치에 넣습니다. 작업 묶음에서 각 프로그램이 실행이 완료되면 바로 다음 프로그램이 실행되도록 하는 시스템입니다. 위의 그림이 해당 예시입니다.

3. Multiprogrammed Batch System :<br>
![multi programing](https://github.com/HeeChanN/HeeChanN/assets/88177732/72e2acce-adeb-465a-969f-d06fa604f7d8)
하지만 단순 일괄 처리 시스템은 CPU가 프로그램이 입출력을 대기할 동안 대기해야 하는 일이 발생하여 비효율성을 초래합니다. 따라서 CPU가 특정 프로그램을 실행하다가 입출력 대기를 할 경우 다른 프로그램에게 제어를 넘기는 방법이 바로 `**Multiprogrammed Batch System**` 입니다. 입출력 장치가 CPU에 비해 느리다는 특징을 바탕으로 앞에서 배운 인터럽트 개념이 여기서 등장합니다. 현재 프로그램이 입출력 연산으로 대기하게 될 경우 입출력 대기를 하지 않는 프로그램으로 CPU 제어를 넘기는 방법입니다. 

<br>

> 초기 멀티프로그래밍같은 경우 오직 CPU 이용율에만 집중하여 프로그램이 I/O 작업을 진행할 떄만 프로세스 스위칭이 발생했습니다. 즉, (Time out)이 존재하지 않았습니다. 이런 Time out이 왜 필요할까요? 현재 단원에서 간략하게 설명하자면 Time out이 존재하지 않으면 특정한 하나의 프로그램이 CPU를 독점할 수 있습니다. 따라서 Time out은 이런 점을 방지하기 위해 존재한다고 보면 됩니다. 나중에 성능과 fairness라는 개념에서 등장하므로 지금은 단순하게만 짚고 넘어가겠습니다!
{: .prompt-warning }

4. Time-Sharing System (시분할) :<br>
멀티프로그래밍을 이용한다면 효율적인 일괄처리가 가능해 집니다. 그러나 많은 작업이 존재할 경우 사용자와 컴퓨터 간의 직접 대화 모드를 제공하는 것이 좋습니다 (터미널, cmd).<br><br> 
멀티프로그래밍을 통해 CPU가 다수의 일괄처리 작업을 동시에 처리할 수 있는 것과 마찬가지로 다수의 대화형 작업을 처리할 때도 멀티프로그래밍 개념이 사용될 수 있는데 이를 `**시분할 기법**`이라고 합니다. 시분할 시스템에서는 각 사용자 프로그램이 짧은 시간동안 번갈아 수행되도록 해주는 운영체제를 통해 다수의 사용자가 터미널을 이용하여 동시에 시스템에 접근할 수 있습니다. 

```text
만약 서비스를 요청하는 사용자가 n명이라면 운영체제 오버헤드를 무시할 때 사용자들은 평균적으로 실제 컴퓨터 능력의 1/n만을 사용하게 된다. 하지만 이 속도도 사용자의 반응속도에 비하면 상대적으로빠르기에 각 사용자는 자신이 컴퓨터를 독점적으로 사용하는것 처럼 느낍니다.
``` 

이렇게 운영체제가 발전하며 이루어진 네가지 이론적 진전이 있습니다. **프로세스**, **메모리 관리**, **정보 보호**, **스케쥴링 및 자원관리** 입니다. 앞으로 이런 운영체제 발전의 주요 성과에 해당하는 이 4가지 요소에 대해 각 단원에서 등장할 것이고 해당 단원에서 자세하게 설명할 예정입니다. 따라서 지금은 지금까지 정리된 OS의 기능 4가지라고만 기억하시면 될 것 같습니다.

앞의 4가지 요소는 거의 대부분의 OS의 기능에 해당한다면 앞으로 나올 요소들은 OS마다 다를 수 있는 부분들 입니다.

<br>

## 3. 최근 운영체제로의 발전
---

이 방식들은 아직 정리가 진행중인 방식들로 현재 상용 운영체제들에서 시도되고 있는 작업들 입니다.

1. 단일 커널 아키텍쳐 (Microkernel Architecture) :<br>
메모리 공간, 프로세스간 통신, 스케쥴링을 포함한 소수의 핵심 기능만 Kernel에 포함시키고 그 밖의 운영체제 서비스들은 서버라고 불리는 프로세스에 의해 제공되는데 이 프로세스들은 모두 User 모드로 실행되며 Mirco Kernel에 의해 일반 프로그램과 동일하게 취급됩니다. 이 방식은 계층구조를 연상시키는 방법으로 커널과 서버의 개발이 분리 될 수 있다는 장점이 있습니다.

2. 멀티쓰레딩(Multithreading):<br>
프로세스를 동시에 수행될 수 있는 쓰레드로 분할하는 기법입니다. 쓰레드와 프로세스를 아주 간단하게 비교해보면 프로세스는 하나의 프로그램이라고 생각하면 되고 쓰레드는 그 하나의 프로그램에서 작업의 단위라고 생각하면 됩니다. 멀티쓰레딩은 이런 여러개의 상호 독립적인 쓰레드들이 작업을 동시에 처리하는 방식입니다. 

> 멀티프로세스를 쓰면되지 왜 멀티 쓰레드를 쓰나요? 쓰레드와 쓰레드사이의 CPU 제어권 변경보다 프로세스 사이의 CPU 제어권이 변화되는데 들어가는 비용이 더 많아서 교환에 들어가는 오버헤드가 훨씬 적다고 볼 수 있습니다.
{: .prompt-warning }

웹 서버-클라이언트 구조에서 서버 애플리케이션이 클라이언트로부터 요청이 도착하기를 기다렸다가 요청이 들어오면 쓰레드 단위로 요청을 처리하는 구조에서 유용합니다.


3. SMP (Symmetric Multiprocessing):<br>
CPU를 여러개 동시 실행 가능한 구조로, 동시에 엑세스 할 수 없는 정보들은 순차적 작업 필요합니다 (Concurrency control). 단일 처리기같은 경우 다른 프로세스가 CPU를 차지하고 실행 중이라면 대기해야하는데 다수의 CPU의 경우 각 CPU마다 프로세스가 차지하고 동시에 실행될 수 있습니다.


## 4. 마무리 하며...
---
<br>

앞으로 멀티프로그래밍, 멀티 쓰레딩, 프로세스, 쓰레드, 메모리 관리, 스케쥴링같은 운영체제가 관리하는 기능들에 대해 알아갈 예정이며 이전에 빠르게 공부하며 넘어갔던 부분들에 예시를 적용해 보며 깊게 공부해 보고자 합니다. 저는 최근 Unix프로그래밍 수업을 들으며 시스템콜을 사용해 보고 프로세스를 생성해 보는 실습을 진행하며 운영체제란 개념이 조금더 확실해져 가고 있다고 생각합니다. CS는 알아가면 알아갈 수록 서로 유기적으로 연결되어있어 공부를 하는 즐거움이 있는 것 같습니다!😊