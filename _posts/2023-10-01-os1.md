---
title: "[운영체제] 0. 컴퓨터 시스템 개요 (명령어 수행 + 인터럽트)"
date: 2023-10-01 00:00:00 +09:00
categories: [CS, 운영체제]
tags:
  [
    명령어,
    운영체제,
    인터럽트,
    컴퓨터 구조
  ]
---

<br>


> 본격적으로 운영체제에 대해 공부하기 전에 컴퓨터 시스  템의 구조와 각각의 명칭들에대한 개념들을 잡고 시작하면 앞으로 나올 내용을 이해하는데 도움이 많이 되므로 시스템의 구조와 명칭들의 정의로 시작하려고 합니다! 


## 1. 기본 구성 요소 및 CPU



![컴퓨터 구조](https://github.com/HeeChanN/HeeChanN.github.io/assets/88177732/080f5cdc-0c6b-404b-955d-da1e4b07dab6) 


먼저 컴퓨터의 기본 구조를 간략하게 표현하면 위의 그림과 같은 구조입니다. 기본 구성 요소는 CPU, Main Memory, I/O Module, System Bus로 이루어져 있습니다.
<br>

1. `CPU` : 컴퓨터의 동작을 제어하고 데이터를 처리하는 장치입니다.

2. `Main Memory` : 데이터와 프로그램을 저장하고 휘발성의 특징을 갖습니다. 컴퓨터를 종료하면 메모리의 내용 사라지고, 하드디스크 메모리는 유지됩니다. 각자 컴퓨터의 RAM이라고 생각하시면 됩니다!

3. `I/O Module` : 하드디스크, 단말기, 프린터,키보드 등등이 존재한다고 생각하시면 됩니다.

4. `System Bus` : CPU, 메모리, I/O모듈 사이의 데이터가 이동하는 장소입니다. 각 장치들이 갖고있는 정보들을 서로 교환할 수 있게 도와주는 통로입니다.

각각의 장치들은 앞으로 종종 사용될 것이고 이 장치들에 대한 개념이 부족하시면 컴퓨터 구조를 추가적으로 공부하시고 돌아오신다면 충분히 내용을 쉽게 이해하실 수 있습니다!


<br>

그럼 `CPU`는 컴퓨터의 동작을 제어하고 데이터를 처리한다는데 어떻게 작동을 하는 것일까?

--> `CPU` 그림을 보면 **PC**, **IR** 등등 네모난 박스가 보일 것입니다. 해당하는 박스들이 바로 **레지스터**들로 데이터나 명령어를 저장하고 해당 명령어를 해석하여 동작을 수행한뒤 다음 명령어를 처리하는 역할들을 담당하는 녀석들입니다. 적혀있는 레지스터들을 분류해 보면 아래 와 같습니다.

<br>

1. 범용 레지스터 : 임시로 데이터를 저장하는 레지스터

2. Control Register 
	- `PC` = 다음 실행할 명령어의 주소가 저장되어있는 레지스터
    - `IR` = 현재 수행하고 있는 명령어가 저장되어있는 레지스터
    - `MAR` = 메모리에 접근할 시 사용할 주소를 저장하는 레지스터 
    - `MBR` = 메모리에서 데이터를 불러오거나 새로 데이터를 적을 때 임시로 해당 데이터를 저장하는 레지스터
    - `I/O AR` = 입출력 장치에 접근할 때 사용할 주소 저장
    - `I/O BR` = 입출력 장치와 CPU 간의 데이터 교환을 위해 사용
    
    
3. PSW (Program Status Words) == 상태 레지스터
    - Condition codes
    - 인터럽트 enable / disable 비트
    - Supervisor / usermode 비트


먼저 범용 레지스터와 Control 레지스터는 명령어 수행 과정을 컴퓨터 구조에서 배웠다면 익숙하실 것입니다. MAR과 MBR이 아마 처음 보는 레지스터일 수 있는데 해당 레지스터는 앞으로 나올 명령어 수행 과정에서 자세하게 설명해 드리겠습니다. PSW는 이후에 나올 단원에서 중요한 레지스터인데 현재는 그냥 CPU가 현재 실행하고 있는 프로그램의 정보를 기록하는 레지스터라고만 생각하시고 나중에 좀 더 자세하게 알아보겠습니다!

**각 레지스터들이 이해하기 어려우시다면 컴퓨터 구조를 공부하시고 오는걸 추천드립니다!! **

각각의 기능들을 가진 레지스터를 이용하여 CPU는 명령어를 수행합니다. **앞선 의문은 바로 어떻게 컴퓨터의 동작을 제어하는지였는데** 명령어와 레지스터로 이 역할을 수행합니다. **그럼 이 명령어 수행과정은 어떻게 될까요?** 이 내용도 컴퓨터 구조의 내용이지만 앞으로 공부할 인터럽트에서 이 명령어 수행 과정이 필요하므로 간략하게 설명해 드리겠습니다!

<br>


## 2. 명령어 수행 과정


<br>


![os2](https://github.com/HeeChanN/HeeChanN.github.io/assets/88177732/d7a266d6-ea22-4397-a313-a8c312504c1a)


명령어 수행과정을 설명하기 위해 간단한 프로그램을 실행시킨다고 가정해 보겠습니다. **먼저** 해당 프로그램을 실행시키면 메인메모리에 해당 프로그램을 위치시킵니다. **이후** 해당 프로그램의 첫 주소 (메인메모리에 들어간 위치)를 PC라는 레지스터에 저장합니다. **다음 과정**이 바로 그림에 나온 과정인데, 이 PC에 담긴 주소값을 이용하여 Fetch 단계를 수행하고 해당 결과로 나온 내용으로 Excute 단계에서 명령어를 수행합니다. 이 Fetch와 Excute 단계를 CPU 레지스터와 함께 동작 과정을 표현해 보겠습니다.
<br>

**Fetch Stage**

1. PC값 (메인 메모리 주소 값)을 MAR에 옮기고 PC값을 1증가 시킵니다. MAR의 개념이 여기서 등장하는데 MAR은 위에서 설명한 그대로 메모리에 접근하려고 할 때 해당 메모리 주소 값을 저장해 두는 공간입니다. 따라서 이후에 나올 단계에서 이 MAR을 보고 메모리에 접근하여 명령어를 가져오는 과정이 일어납니다. PC값을 1 증가시키는 과정은 다음 명령어를 추가적으로 계속 가져오기 위해서 메인 메모리에 있는 프로그램의 다음 명령어가 담긴 주소를 가리키게 하는 과정입니다.

2. MAR의 주소 값으로 메인 메모리에 해당하는 주소값에 있는 명령어를 MBR에 저장합니다. 이 명령어는 저희가 처음에 프로그램을 실행시킨다고 가정한 그 프로그램의 시작을 나타내는 명령어일 것입니다. MBR은 데이터를 불러올 때 사용하는 레지스터라고 하였는데 이 명령어를 일종의 데이터라고 보면 됩니다. 

3. MBR의 내용을 IR로 이동시킵니다. IR은 현재 수행하고 있는 명령어의 주소가 담겨있는 레지스터로 이후에 Excute Stage에서 이 IR에 담긴 명령어를 분석하여 실행시키는 과정이 일어나게 될 것입니다.
<br>

**Execute Stage**

1. IR 레지스터에 담겨있는 명령어를 분석합니다 (디코딩) 이 과정에서 CPU가 어떤 동작을 수행하고 메인메모리에서 어떤 데이터를 가져올지에 대한 정보가 나옵니다.

2. MAR 에 IR을 분석하여 나온 데이터의 위치 (메인메모리 주소 값)을 이동시킵니다. 

3. MAR의 정보를 바탕으로 메인메모리에서 데이터를 읽어 MBR에 저장합니다.

4. AC (누산기) 에 해당 데이터를 적재합니다. AC는 앞에서 설명을 안했는데 산술 논리 연산을 담당하는 녀석입니다. 
<br>

저는 하나의 명령어가 수행되는 과정만 적었지만 이후에 다음 명령어를 읽어 AC에 있는 값에 더하고 또 다음 명령어를 읽어 해당 AC에서 계산한 내용을 메인 메모리에 해당 프로그램에 저장하는 과정이 일어나며 프로그램이 작동할 것입니다. 이런 과정으로 명령어가 작동하게 되고 CPU가 동작을 제어하는 것입니다. **명령어의 수행 과정에서 인터럽트라는 개념이 등장합니다. ** 인터럽트도 프로세스와 쓰레드에 대한 내용에서 계속 등장하므로 자세하게 설명해 드리겠습니다.
<br>

## 3. 인터럽트

<br>

인터럽트라는 개념은 컴퓨터 구조에서 처음 배우는 개념입니다. 운영체제에서 다룰 인터럽트의 주 개념은 CPU의 처리율 향상에 대한 것이라고 보면 됩니다. 
먼저 인터럽트의 종류는 크게 4가지로 나눠볼 수 있습니다.

1. **프로그램 인터럽트** : 명령어 수행 결과로 발생하는 조건에 의해 생성됩니다. 예를 들어 오버플로우, 0으로 나누기, 잘못된 기계 명령어 실행, 잘못된 인덱스 참조 등과 같은 프로그램 내부의 실행에 문제가 발생하여 인터럽트 되는 것입니다. 우리가 만든 코드에서 오류를 찾을 때 보통 이런 프로그램 인터럽트를 경험해 볼 수 있습니다. Java 언어로 생각해 볼 때 크기가 5인 배열에서 인덱스 5인 요소에 접근하려하면 **IndexOutOfBoundsException** 예외가 발생하는 것이 이와 같은 인터럽트라고 생각하면 이해하기 쉬울 것입니다.

2. **타이머 인터럽트** : 모든 프로그램은 자기에게 할당된 시간이 존재합니다. 따라서 주어진 시간이 끝나면 인터럽트가 발생합니다. ( Time out에 의한 인터럽트)

3. **I/O 인터럽트** : I/O 디바이스가 입출력 작업을 끝냈다는 걸 알려주는 인터럽트 입니다. 대부분의 I/O 장치들은 CPU에 비해 매우 느리기 때문에 다른 I/O 장치들에서 입출력 연산이 수행되는 동안에 CPU가 이것을 대기하게 되면 CPU라는 자원을 낭비하게 됩니다. 따라서 I/O장치가 입출력 연산을 할 때 CPU는 다른 명령어를 수행시켜 CPU사용 효율을 늘릴 수 있습니다. 

4. **Hardware Failure 인터럽트 :** 하드웨어 구성 요소가 기대한 동작을 수행하지 못하는 상태를 말합니다. 예를 들어, 키보드의 키가 입력되지 않는 경우를 예를 들 수 있습니다.

<br>

운영체제에서는 타이머 인터럽트와 I/O인터럽트를 중요하게 다룹니다. 타이머 인터럽트는 프로세스와 쓰레드 개념과 함께 자주 사용될 예정이고 I/O인터럽트로 명령어 수행과정에서 인터럽트가 발생하는 과정을 설명해 드리겠습니다.
<br>

## 4. I/O 인터럽트 발생 과정

<br>

I/O 인터럽트의 과정은 먼저 외부 장치의 입출력 모듈이 인터럽트 요청을 CPU에 보냅니다. 이에 대한 반응으로 CPU는 수행중이던 프로그램의 작업을 보류하고 인터럽트 처리기(Interrupt Handler)로 분기합니다. 

 
![](https://github.com/HeeChanN/HeeChanN.github.io/assets/88177732/32d6660e-24a4-48a4-8fbd-e39e50b7beb2)

이 그림이 인터럽트 과정을 잘 표현해 줍니다.

1. 먼저 1번 단계는 사용자 프로그램을 실행중인데 write형태의 System Call을 시작하는 지점에 사용자 프로그램이 도달하면 호출되는 입출력 프로그램은 준비 코드와 실제 입출력 명령으로 이루어져 있습니다.

2. 이러한 명령어를 수행한 후에 CPU의 제어는 사용자 프로그램으로 리턴되고 외부 장치는 컴퓨터 메모리로부터 받은 데이터를 출력합니다. 

3. 이러한 출력 작업이 진행될 때 CPU는 사용자 프로그램을 이어서 실행하고 도중에 입출력 프로그램에서 출력 진행이 끝난다면 인터럽트 요청 신호를 CPU에게 보냅니다. CPU는 현재 수행중이던 프로그램의 2a 부분을 종료하고 해당 입출력 장치를 서비스하기위한 루틴인 인터럽트 핸들러라라고 불리는 프로그램으로 분기합니다.

4. 이후 5번 과정을 끝낸 후에 다시 원래 프로그램의 2a 이후 단계인 2b로 돌아와 프로그램의 진행을 재개합니다.
<br>

![os5](https://github.com/HeeChanN/HeeChanN.github.io/assets/88177732/dc7c1956-8710-4731-a698-6acbcdd4fc19) 

위에서 명령어 수행과정에 인터럽트 처리 단계를 붙이면 위와 같은 그림이 나오게 됩니다. 명령어 수행(Excute Instruction)단계 이후 인터럽트 발생 여부를 검사합니다. 이 단계에서 사용되는게 PSW의 인터럽트 enabled/disabled 비트 입니다. 만약 명령어 실행 도중에 인터럽트가 발생되었다면 CPU는 그 정보를 기록하고 명령어 실행 과정 이후 해당 인터럽트를 건 I/O 핸들러로 분기합니다. 
<br>

따라서, 인터럽트는 하드웨어가 관련하는 부분과 소프트웨어가 관련하는 부분으로 나누어 볼 수 있습니다.

![os4](https://github.com/HeeChanN/HeeChanN.github.io/assets/88177732/a4f8b1a9-8544-4687-ab88-281a7c64e5a0) 

위의 그림으로 하드웨어와 소프트웨어과 어떻게 인터럽트를 수행하는지 설명해 드리겠습니다.

**하드웨어 Stage**

1. 어떤 특정한 하드웨어 장치가 인터럽트를 걸어야 I/O인터럽트가 시작됩니다.
2. CPU(Processor)가 현재 명령어의 실행을 완료시키고 인터럽트가 걸렸는지 확인합니다.
3. CPU(Processor)가 인터럽트 비트로 확인 후에 인터럽트 확인 신호를 보냅니다.
4. PSW와 PC값 같은 중요한 Status 레지스터와 Control Register의 값들을 위의 그림의 Control Stack에 저장합니다.
5. CPU는 인터럽트에 해당하는 새로운 PC값을 적재합니다. 이 새로운 값은 보통 인터럽트 핸들러의 주소를 적재합니다. 인터럽트 핸들러는 OS 프로그램으로 이 부분에서 하드웨어 -> 소프트웨어의 단계로 바뀝니다. 
여기서 OS 핸들러의 주소를 PC값에 적재한다는 것을 설명해 드리겠습니다. 컴퓨터의 인터럽트 과정에서 프로그램 A에서 바로 입출력 프로그램 B로 넘어가지 않습니다. 중간에 OS가 개입해 이 과정을 진행해야 합니다. 따라서 이 과정을 도와주는 OS인 인터럽트 핸들러를 실행 시키기 위해 PC값에 해당 인터럽트 핸들러의 주소를 적재하여 인터럽트를 진행시킵니다.

**소프트웨어 Stage**

6. 인터럽트 핸들러(OS)는 현재 실행중이었던 프로세스(유저 프로그램)의 나머지 상태정보를 Control Stack에 저장합니다. 이 과정은 나중에 원래 중지되었던 프로세스로 돌아왔을 때 다시 그 프로그램의 중지됬던 지점에서 실행 시키기 위해 하는 작업입니다. 

7. 인터럽트를 처리합니다.

8. 프로세스의 General Register를 복구합니다.

8. 이전의 PSW와 PC값을 복구합니다.

<br>

이런 Step을 통해 인터럽트의 과정이 일어나고 앞으로 배울 운영체제 개념에서 인터럽트라는 개념은 매우 중요하므로 꼭 잘 이해하셔서 학습에 도움이 되셨으면 좋겠습니다!


## 5. 0단원 마무리

<br>
학부 3학년 1학기 때 배웠던 운영체제를 복습할 겸 자세하게 정리하고 싶어 쓴 글이 첫번째 단원부터 엄청 길어진 것 같습니다. 보통 운영체제를 배우기 전에 컴퓨터 구조를 배우고 학습을 진행하기에 컴퓨터 구조에 대한 자세한 개념들은 많이 생략한것 같아서 보시면서 제가 설명을 덜한 부분에서 이해가 안되신다면 질문을 남겨주세요! 또한 제가 알고 있는 지식이 잘못되었을 수 있으니 잘못된점이 보인다면 정정 부탁드립니다!