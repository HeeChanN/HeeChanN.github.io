---
title: "부하테스트 도구 선택 (1)"
date: 2025-3-01 22:53:00 +09:00
categories: [부하테스트, locust]
tags:
  [
    부하테스트,
    모니터링,
    locust,
    서버 비용,
    성능 최적화,
    AWS
  ]
---

> 프로젝트 배포 환경에 부하테스트를 진행하기 위해 부하테스트 툴로 Locust를 결정하게 된 이유와 Locust를 사용하는 방법에 대하여 학습한 내용을 적어보았습니다.  


## 1. 부하테스트 툴 선정 (Jmeter, k6, locust)

가장 먼저 어떤 부하테스트 툴을 사용할지 고민했습니다. 저는 이전에 처음 부하테스트를 해보려고 했을 때, Jmeter라는 툴을 사용했는데, 당시 빠르게 부하테스트를 어떻게 진행하는지 경험해보기 위해 자세하게 찾아보지 않고 진행했던 적이 있습니다.

해당 시점에 jmeter를 선정했던 이유는 단지 다음 2가지였습니다.

1. java 애플리케이션이라 친숙하다.
2. GUI를 제공한다. (CLI보다는 GUI지~)

하지만 실제로 직접 사용해보았을 때, 느꼈던 점은 **"GUI가 너무 복잡하다"** 였습니다.


![uniprograming](https://github.com/HeeChanN/HeeChanN/assets/88177732/3bff288d-837e-4ed5-b264-9774dad65e62)

이 그림은 실제로 jmeter를 실행하면 보는 화면입니다. GUI에 기능이 많아 복잡하고, 실제 하나의 요청을 보내고 응답을 받아오는 sampler를 만들 때, 기본적으로 들어가는 학습 비용이 존재했습니다.

최종적으로 간단한 시나리오를 작성하는 것은 문제가 없지만 실제 서비스 로직을 반영하여 시나리오를 작성하고 해당 시나리오를 저장해놓는 구조가 너무 번거롭다고 느꼈습니다.

이런 근거를 바탕으로 이번 부하테스트 툴에서는 몇 가지 기준을 바탕으로 부하테스트 툴을 선정하였습니다.

1. 사용자 시나리오 테스트를 작성하기 편리한 도구
2. 부하테스트 결과를 쉽게 확인할 수 있는 도구

이 근거로 선정하게 된 것이 바로 Locust였습니다.

<br>

### Locust 선택 이유

먼저 Jmeter의 경우는 위 이유로 선택의 폭에서 제외되었고, 1번 조건을 만족하기 위해서 코드 기반 시나리오 작성을 우선적으로 찾아보게 되었습니다.

그중 대표적으로 K6의 자바스크립트 기반 시나리오 작성과 Locust의 파이썬 기반 시나리오 작성이 존재했습니다. 두 언어 모두 시나리오를 작성하는 수준까지는 어렵지 않게 수행할 수 있어 1번 조건으로 2가지 툴로 선택의 폭을 좁히게 되었습니다.

여기서 Locust와 K6를 선택하는 기준은 쉽게 부하테스트 결과를 볼 수 있다는 점을 근거로 선택하였습니다.

예를 들어 K6를 선택하였을 때, k6는 기본적으로 GUI 형태의 시각화 도구가 내장되어있지 않아 CLI 출력만으로 실시간 테스트 지표를 봐야했습니다. 
그래프 대시보드를 통해 결과를 모니터링 하고 싶다면 Promethous + Grafana 모니터링 시스템에 연동해야 한다는 추가적인 비용이 발생했습니다. 
즉, 아래와 같이 K6를 따로 모니터링 시스템과 연동하는 과정을 진행해야했습니다.

![k6](https://github.com/user-attachments/assets/b0d22898-d3f2-4167-b4e8-e05bdbb2e8ea)

그에 반해, Locust의 경우 기본적으로 제공되는 웹 UI가 존재했고 local 환경에서 즉시 부하테스트 결과를 실시간으로 볼 수 있다는 점에서 최종적으로 Locust를 선택하게 되었습니다.

여기서 물론 서버의 매트릭은 Prometheus와 Grafana를 거쳐 사용자에게 전달되어야 합니다.
따라서, k6를 연동하는 작업이 문제가 없고 자바스크립트 기반 시나리오 작성을 원하면 K6 선택을 해도 무방하다고 생각합니다.

<br>

## 2. Locust 사용해보기

https://docs.locust.io/en/stable/index.html

위 사이트를 기반으로 학습을 진행했습니다. 

먼저 따로 저는 파이썬 가상환경을 생성하여 진행했습니다. 따라서 아래와 같은 구조로 locust를 설치했습니다.


```console
가상환경 생성 (window)
python -m venv venv
ㅉ
가상환경 실행 (window)
.\venv\Scripts\Activate.ps1

locust 설치
pip install locust
```


locust의 경우 하나의 모듈이기 떄문에 다른 패키지를 import해서 작성할 수 있다는 장점이 존재합니다. 따라서 시나리오 작성시 쉽게 하나의 시나리오를 완성할수 있습니다. 다음은 제가 연습할 때 사용했던 스크립트입니다.


```python
from locust import HttpUser, task, between

class ConcertScenarioUser(HttpUser):
    wait_time = between(1, 3)

    @task
    def festival_info_scenario(self):
        for i in range(3):
            concert_id = i
            with self.client.get(
                f"/concert/{concert_id}", name="/concert/<id>", catch_response=True
            ) as response:
                if response.status_code != 200:
                    response.failure(f"Failed /concert/{concert_id}")
```


Class를 선언하고고 해당 클래스내에서 수행할 작업을 메서드로 명시합니다. 만약 여러개의 메서드가 있다면 `@task(1)`, `@task(2)`와 같이 숫자를 붙여 가중치를 줄 수 있습니다. `wait_time`을 설정하여 실제 사용자들이 요청을 보내는 것처럼 사용자가 이용하는 형태와 비슷하게 만들어 줄 수 있습니다. `HttpUser`는 python의 requests 라이브러리를 사용하는 기본적인 사용자(User) 클래스입니다. requests 라이브러리는 동기적으로 작동하기 때문에, 하나의 요청을 보내고 하나의 요청이 완료될 때까지 다음 요청을 보내지 않습니다. 따라서 부하테스트에는 맞지 않고 일반적인 요청 테스트를 진행할 때 사용해 볼 수 있습니다.

Locust에서는 따로 `FastHttpUser`를 제공합니니다. 이는 gevent 기반의 비동기를 이용하여 요청을 보낸 후 응답을 기다리지 않고 다른 작업을 수행할 수 있습니다. 따라서, 더 많은 요청을 처리할 수 있습니다. gevent 기반의 비동기에 대한 내용은 이전 블로그 글을 참고해 주세요. [파이썬 비동기](https://heechann.github.io/posts/python-async-await/)

간단하게 설명하면, 파이썬의 async/await과 비교하면 greenlet은 C 확장으로 구현되어 있어 메모리 사용량이 낮고 Context Switching 오버헤드가 극소화 되어있다는 장점이 있습니다.

따라서, 이런 비동기 기반으로 하나의 CPU 코어에서 HttpUser보다 더 많은 부하를 낼 수 있습니다. 실제로 사용해보았을 때 cpu 코어 하나로 만들 수 있는 가상 사용자수는 제 시나리오 기준 2배정도 차이가 났고 CPU코어 부하가 심할 경우 다음과 같은 문구가 나오는 걸 확인할 수 있었습니다.


```python
[2025-02-28 16:00:16,498] <>/WARNING/root: CPU usage above 90%! This may constrain your throughput and may even give inconsistent response time measurements! See https://docs.locust.io/en/stable/running-distributed.html for how to distribute the load over multiple CPU cores or machines
```

따라서 저는 FastHttpUser를 사용하여 시나리오를 작성하였습니다. HttpUser와 같은 api를 사용하기 때문에 라이브러리만 수정해서 사용하였습니다.

<br>

## 3. master - worker 사용

<br>

파이썬은 GIL로 단일 CPU 코어안에서만 동작합니다. 따라서, 1000개 이상의 가상 사용자를 사용하게 될 때, FastHttpUser를 쓰더라도 제 노트북에서는 CPU 과부하가 발생하였습니다. 이를 master 프로세스와 worker 프로세스로 나누어서 간단하게 여러 코어를 이용해서 `masert - worker` 구조를 만들 수 있습니다. 이 구조를 바탕으로 실제 실행해 보았을 때 1000명의 가상 유저까지는 무리 없이 2개의 파이썬 프로세스로 동작할 수 있었습니다.

```console
Master 프로세스
locust -f my_locustfile.py --master

Worker 프로세스
locust -f - --worker --master-host <your master> --processes 4
```

이 명령어는 fork()를 사용해서 실행되기 때문에 윈도우에서는 사용할 수 없습니다. 따라서 윈도우에서는 아래와 같이 직접 커맨드창을 여러개 열어 원하는 프로세스 수 만큼 실행시켜주었습니다.

```console
cmd 1개
locust -f locust.py --master --web-host 0.0.0.0

새로운 cmd 창 2개
locust -f locust.py --worker --master-host=127.0.0.1
locust -f locust.py --worker --master-host=127.0.0.1
```

이 방식을 통해 간단하게 여러 코어를 이용하여 좀 더 많은 양의 부하를 서버에 줄 수 있습니다. 또한, UI를 통해 각 worker가 몇 개의 쓰레드를 생성했고 메모리는 얼마를 사용하는지 파악할 수 있습니다.

![Image](https://github.com/user-attachments/assets/5c8c67ba-d24c-47cc-a045-fd0d5e58341f)

<br>

## 4. 마무리

<br>
간단하게 Locust를 살펴보았는데 실제로 결과를 바로 웹 아래와 같은 웹 ui로 볼 수 있으며 download data탭을 이용하여 결과치를 csv와 html보고서로 다운받을 수 있습니다. 저는 이번에 사용하며 시나리오도 짜기 쉽고 결과도 바로 볼 수 있다는 점에서 큰 메리트를 느꼈는데 간단한 부하테스트를 하기에 가장 적합한 도구이지 않나 생각합니다.

<br>

![Image](https://github.com/user-attachments/assets/bc43ee23-4e8c-4d98-9262-a6b6cb569775)